#!/usr/bin/env python3
"""
Serwis email Brevo dla CBOSA Bot
Obs≈Çuguje wysy≈Çanie newsletter√≥w przez API Brevo
"""

import os
import logging
import requests
import time
from typing import List, Optional, Union, Dict, Tuple
import base64
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class EmailRecipient:
    """Odbiorca emaila"""
    email: str
    name: str

@dataclass
class EmailContent:
    """Zawarto≈õƒá emaila"""
    subject: str
    html_content: str
    text_content: Optional[str] = None

@dataclass
class EmailSendResult:
    """Wynik wys≈Çania emaila"""
    success: bool
    message_id: Optional[str] = None
    error: Optional[str] = None

class BrevoEmailService:
    """Serwis wysy≈Çania emaili przez Brevo API"""
    
    def __init__(self):
        self.api_key = os.getenv('BREVO_API_KEY')
        if not self.api_key:
            raise ValueError('BREVO_API_KEY nie jest ustawione')
        
        self.base_url = 'https://api.brevo.com/v3'
        self.headers = {
            'api-key': self.api_key,
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        
        logger.info("‚úÖ Serwis email Brevo zainicjalizowany")
    
    def _send_single_email(self, recipient: EmailRecipient, content: EmailContent,
                          sender_email: str, sender_name: str) -> EmailSendResult:
        """
        Wy≈õlij pojedynczy email
        
        Args:
            recipient: Odbiorca
            content: Zawarto≈õƒá emaila
            sender_email: Email nadawcy
            sender_name: Nazwa nadawcy
            
        Returns:
            Wynik wysy≈Çania
        """
        try:
            payload = {
                'sender': {
                    'email': sender_email,
                    'name': sender_name
                },
                'to': [
                    {
                        'email': recipient.email,
                        'name': recipient.name
                    }
                ],
                'subject': content.subject,
                'htmlContent': content.html_content
            }
            
            if content.text_content:
                payload['textContent'] = content.text_content
            
            response = requests.post(
                f'{self.base_url}/smtp/email',
                json=payload,
                headers=self.headers,
                timeout=30
            )
            
            if response.status_code == 201:
                # Sukces
                response_data = response.json()
                message_id = response_data.get('messageId')
                
                logger.debug(f"‚úÖ Email wys≈Çany do {recipient.email}, messageId: {message_id}")
                return EmailSendResult(
                    success=True,
                    message_id=message_id
                )
            else:
                # B≈ÇƒÖd
                error_msg = f"B≈ÇƒÖd HTTP {response.status_code}: {response.text}"
                logger.error(f"‚ùå B≈ÇƒÖd wysy≈Çania do {recipient.email}: {error_msg}")
                return EmailSendResult(
                    success=False,
                    error=error_msg
                )
                
        except requests.exceptions.Timeout:
            error_msg = "Timeout podczas wysy≈Çania emaila"
            logger.error(f"‚ùå {error_msg} do {recipient.email}")
            return EmailSendResult(
                success=False,
                error=error_msg
            )
        except requests.exceptions.RequestException as e:
            error_msg = f"B≈ÇƒÖd po≈ÇƒÖczenia: {str(e)}"
            logger.error(f"‚ùå {error_msg} do {recipient.email}")
            return EmailSendResult(
                success=False,
                error=error_msg
            )
        except Exception as e:
            error_msg = f"Nieoczekiwany b≈ÇƒÖd: {str(e)}"
            logger.error(f"‚ùå {error_msg} do {recipient.email}")
            return EmailSendResult(
                success=False,
                error=error_msg
            )
    
    def validate_email(self, email: str) -> bool:
        """
        Waliduj adres email
        
        Args:
            email: Adres email do walidacji
            
        Returns:
            True je≈õli email jest prawid≈Çowy
        """
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    def send_email(
        self,
        recipients: List[EmailRecipient],
        content: EmailContent,
        sender_email: str = 'newsletter.automatic.bot@gmail.com',
        sender_name: str = 'CBOSA Bot',
        attachments: Optional[List[Union[str, Tuple[str, bytes], Dict[str, str]]]] = None,
    ) -> List[EmailSendResult]:
        """
        Wy≈õlij email do listy odbiorc√≥w.

        attachments:
            - lista ≈õcie≈ºek do plik√≥w (str), lub
            - lista krotek (name: str, data: bytes), lub
            - lista s≈Çownik√≥w w formacie Brevo: {"name": "...", "content": "<base64>"} lub {"name": "...", "url": "https://..."}
        """
        results = []
        # pre-normalizacja za≈ÇƒÖcznik√≥w do formatu akceptowanego przez Brevo
        normalized_attachments = self._normalize_attachments(attachments) if attachments else None

        batch_size = 50
        for i in range(0, len(recipients), batch_size):
            batch = recipients[i:i + batch_size]
            for recipient in batch:
                result = self._send_single_email(
                    recipient, content, sender_email, sender_name, normalized_attachments
                )
                results.append(result)
                time.sleep(0.1)  # delikatne odciƒÖ≈ºenie limit√≥w API

        successful = sum(1 for r in results if r.success)
        logger.info(f"üìß Wys≈Çano {successful}/{len(results)} emaili pomy≈õlnie")
        return results

    def _send_single_email(
        self,
        recipient: EmailRecipient,
        content: EmailContent,
        sender_email: str,
        sender_name: str,
        attachments: Optional[List[Dict[str, str]]] = None,
    ) -> EmailSendResult:
        """
        Wy≈õlij pojedynczy email (opcjonalnie z za≈ÇƒÖcznikami).
        """
        try:
            payload = {
                'sender': {'email': sender_email, 'name': sender_name},
                'to': [{'email': recipient.email, 'name': recipient.name}],
                'subject': content.subject,
                'htmlContent': content.html_content,
            }
            if content.text_content:
                payload['textContent'] = content.text_content

            # Brevo SMTP API: klucz 'attachment' (lista obiekt√≥w z 'name' + 'content' (base64) lub 'url')
            if attachments:
                payload['attachment'] = attachments

            response = requests.post(
                f'{self.base_url}/smtp/email',
                json=payload,
                headers=self.headers,
                timeout=30
            )

            if response.status_code == 201:
                response_data = response.json()
                message_id = response_data.get('messageId')
                logger.debug(f"‚úÖ Email wys≈Çany do {recipient.email}, messageId: {message_id}")
                return EmailSendResult(success=True, message_id=message_id)

            error_msg = f"B≈ÇƒÖd HTTP {response.status_code}: {response.text}"
            logger.error(f"‚ùå B≈ÇƒÖd wysy≈Çania do {recipient.email}: {error_msg}")
            return EmailSendResult(success=False, error=error_msg)

        except requests.exceptions.Timeout:
            error_msg = "Timeout podczas wysy≈Çania emaila"
            logger.error(f"‚ùå {error_msg} do {recipient.email}")
            return EmailSendResult(success=False, error=error_msg)
        except requests.exceptions.RequestException as e:
            error_msg = f"B≈ÇƒÖd po≈ÇƒÖczenia: {str(e)}"
            logger.error(f"‚ùå {error_msg} do {recipient.email}")
            return EmailSendResult(success=False, error=error_msg)
        except Exception as e:
            error_msg = f"Nieoczekiwany b≈ÇƒÖd: {str(e)}"
            logger.error(f"‚ùå {error_msg} do {recipient.email}")
            return EmailSendResult(success=False, error=error_msg)

    def _normalize_attachments(
        self,
        attachments: List[Union[str, Tuple[str, bytes], Dict[str, str]]]
    ) -> List[Dict[str, str]]:
        """
        Znormalizuj r√≥≈ºne formy wej≈õcia do formatu akceptowanego przez Brevo:
        [{"name": "...", "content": "<base64>"}] lub [{"name": "...", "url": "https://..."}]
        """
        norm: List[Dict[str, str]] = []
        for att in attachments:
            # ≈öcie≈ºka do pliku
            if isinstance(att, str):
                path = att
                name = os.path.basename(path)
                with open(path, 'rb') as f:
                    b64 = base64.b64encode(f.read()).decode('ascii')
                norm.append({"name": name, "content": b64})
                continue

            # Krotka (name, bytes)
            if isinstance(att, tuple) and len(att) == 2 and isinstance(att[0], str) and isinstance(att[1], (bytes, bytearray)):
                name, data = att
                b64 = base64.b64encode(bytes(data)).decode('ascii')
                norm.append({"name": name, "content": b64})
                continue

            # Ju≈º sformatowany s≈Çownik (content/url)
            if isinstance(att, dict):
                # walidacja podstawowa
                if 'name' in att and ('content' in att or 'url' in att):
                    norm.append(att)
                    continue

            raise ValueError("Nieprawid≈Çowy format za≈ÇƒÖcznika: "
                             "u≈ºyj ≈õcie≈ºki (str), krotki (name: str, data: bytes) lub dict z 'name' i 'content'/'url'.")

        return norm

    def send_bulk_newsletter(
        self,
        recipients: List[EmailRecipient],
        newsletter_html: str,
        config_name: str,
        attachments: Optional[List[Union[str, Tuple[str, bytes], Dict[str, str]]]] = None,
    ) -> List[EmailSendResult]:
        """
        Wy≈õlij newsletter do wielu odbiorc√≥w (obs≈Çuga za≈ÇƒÖcznik√≥w).
        """
        from datetime import datetime
        current_date = datetime.now().strftime('%d.%m.%Y')
        subject = f"Biuletyn CBOSA: {config_name} - {current_date}"

        content = EmailContent(
            subject=subject,
            html_content=newsletter_html,
            text_content="Biuletyn dostƒôpny jest w wersji HTML. Proszƒô w≈ÇƒÖczyƒá wy≈õwietlanie HTML w kliencie email."
        )

        logger.info(f"üì§ Wysy≈Çanie newslettera '{config_name}' do {len(recipients)} odbiorc√≥w")
        return self.send_email(recipients, content, attachments=attachments)
    
    def test_connection(self) -> bool:
        """
        Przetestuj po≈ÇƒÖczenie z API Brevo
        
        Returns:
            True je≈õli po≈ÇƒÖczenie dzia≈Ça
        """
        try:
            response = requests.get(
                f'{self.base_url}/account',
                headers=self.headers,
                timeout=10
            )
            
            if response.status_code == 200:
                account_info = response.json()
                logger.info(f"‚úÖ Po≈ÇƒÖczenie z Brevo dzia≈Ça. Konto: {account_info.get('email', 'Unknown')}")
                return True
            else:
                logger.error(f"‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z Brevo: HTTP {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd testowania po≈ÇƒÖczenia z Brevo: {e}")
            return False